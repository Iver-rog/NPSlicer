use nalgebra::{Point3,Point2,Vector3,Vector2};

use std::io::{self,prelude,Write,BufWriter,BufReader};
use std::fs::File;

use std::env;
use crate::geo::{polygons_from_contours, Contour, Contour3d, Polygon};
use crate::stl_op;



pub struct Settings{
    layer_thickness: f32,
    infill_percentage: usize,
    nozzle_diameter: f32,
    perimeter_line_width: f32,
    infill_line_width: f32,
    n_perimeters: usize,
    infill_overlap_percentage: usize,
    z_hop: f32,
       
    max_staydown_distance: f32,
    min_edge_length: f32,   // mm
    filament_diameter: f32, // mm
    layer_fan_start: usize,
    perimeter_start_xy: [isize;2],
    translate_xy: [usize;2],

    safe_z:f32,
}
impl Default for Settings {
    fn default() -> Self {
        let layer_thickness = 0.2;
        let nozzle_diameter = 0.6;
        let infill_percentage = 20;
        Self {
            layer_thickness,
            infill_percentage: 20,
            nozzle_diameter,
            perimeter_line_width: 0.45,
            infill_line_width: 0.6,
            n_perimeters: 2,
            infill_overlap_percentage: 0,
            z_hop: layer_thickness,
               
            max_staydown_distance: 1.5 * nozzle_diameter/((infill_percentage/100) as f32),
            min_edge_length: 0.5,       // mm
            filament_diameter: 1.75,    // mm
            layer_fan_start: 3,
            perimeter_start_xy: [-30, -15],
            translate_xy: [100, 100],

            safe_z: 0.0,
        }
    }
}

fn writeheader<W: Write>(f:&mut BufWriter<W>,settings:&Settings) -> Result<(),io::Error> {
    writeln!(f,"; Generated by layer-gen-rs")?;
    writeln!(f," Layer thickness: {}",settings.layer_thickness)?;
    writeln!(f," Nozzle diameter: {}",settings.nozzle_diameter)?;
    writeln!(f," Filament diameter: {}",settings.filament_diameter)?;
    writeln!(f,"; Perimeter line width: {}",settings.perimeter_line_width)?;
    writeln!(f,"; Infill line width: {}",settings.infill_line_width)?;
    // writeln!(f,"; Infill angle: {}",settings.infill_angle)?;
    // writeln!(f,"; Infill line spacing: {}",settings.infill_line_spacing)?;
    writeln!(f,"; Layer fan start: {}",settings.layer_fan_start)?;
    writeln!(f,"; Max staydown distance: {}",settings.max_staydown_distance)?;
    // writeln!(f,"; Seam position: {}",settings.seam_position)?;
    // writeln!(f,"; Translate XY: {translate_xy}")?;

    // Starting gcode from PrusaSlicer MK3 config
    writeln!(f,"M201 X1000 Y1000 Z200 E5000 ; sets maximum accelerations, mm/sec^2")?;
    writeln!(f,"M203 X200 Y200 Z12 E120 ; sets maximum feedrates, mm / sec")?;
    writeln!(f,"M204 S1250 T1250 ; sets acceleration (S) and retract acceleration (R), mm/sec^2")?;
    writeln!(f,"M205 X8.00 Y8.00 Z0.40 E4.50 ; sets the jerk limits, mm/sec")?;
    writeln!(f,"M205 S0 T0 ; sets the minimum extruding and travel feed rate, mm/sec")?;
    writeln!(f,"G90 ; use absolute coordinates")?;
    writeln!(f,"M83 ; extruder relative mode")?;
    writeln!(f,"M104 S180 ; set extruder preheat temp")?;
    writeln!(f,"M106 ; Fan on")?;
    writeln!(f,"M140 S60 ; set bed temp")?;
    writeln!(f,"M190 S60 ; wait for bed temp")?;
    writeln!(f,"M104 S215 ; set extruder temp")?;

    writeln!(f,"G28 W ; home all without mesh bed level")?;
    writeln!(f,"G80 ; mesh bed leveling")?;
    writeln!(f,"M104 S215 ; set extruder temp")?;
    writeln!(f,"M109 S215 ; wait for extruder temp")?;

    // Purge f,line
    writeln!(f,"G1 Z0.2 F720")?;
    writeln!(f,"G1 Y-3 F1000 ; go outside print area")?;
    writeln!(f,"G92 E0")?;
    writeln!(f,"M107 ; Fan off")?;
    writeln!(f,"G1 X60 E9 F1000 ; intro line")?;
    writeln!(f,"G1 X100 E12.5 F1000 ; intro line")?;
    writeln!(f,"G92 E0.0")?;

    writeln!(f,"M221 S100 ; M221 - Set extrude factor override percentage")?;
    writeln!(f,"G21 ; set units to millimeters")?;
    writeln!(f,"G90 ; use absolute coordinates")?;
    writeln!(f,"M83 ; use relative distances for extrusion")?;
    writeln!(f,"M900 K0.04 ; Filament gcode LA 1.5")?;
    writeln!(f,"M900 K18 ; Filament gcode LA 1.0")?;
    writeln!(f,"M107 ; Fan off")?;
    Ok(())
}
pub enum ToolPathType{
    Travel,
    Perimeter,
    Infill,
}
pub struct ToolPathLine{
    line:Vec<Point3<f32>>,
    line_type:ToolPathType,
}


pub fn main(blender:&mut crate::Blender) {
    // let args: Vec<String> = env::args().collect();
    // dbg!(&args);
    // let mut args = args.into_iter();
    // let path = args.next().expect("first arg should be the path");
    // let file = args.next().expect("missing argument: stl-layers directory");
    // println!("path:{path}");
    // println!("file:{file}");
    let settings = Settings::default();

    let file_path = "../mesh/bunny-overhang-regions.stl";

    let file = File::open(file_path).expect("Failed to open STL file");
    let mut reader = BufReader::new(file);
    let mesh = stl_io::read_stl(& mut reader).expect("Failed to parse STL file");

    let (indexed_contours,indexed_edges) = stl_op::extract_perimeters_and_edges(&mesh.faces);
    for contour in &indexed_contours{
        blender.edge_loop(contour, &mesh);
    }
    let contours:Vec<Contour> = indexed_contours.into_iter()
        .map(|indexed_contour|{
            Contour::from(
                indexed_contour.into_iter()
                    .map(|vertex_ndx|{
                        let v = mesh.vertices[vertex_ndx];
                        Point2::new(v[0],v[1])
                    })
                    .collect::<Vec<Point2<f32>>>()
                )
        }).collect();
    let polygons = polygons_from_contours(contours);

    let perimeter1:Vec<Polygon> = polygons.clone().into_iter()
        .flat_map(|polygon| polygon.offset(settings.layer_thickness*0.5).into_iter())
        .collect();
    let perimeter2:Vec<Polygon> = polygons.into_iter()
        .flat_map(|polygon| polygon.offset(settings.layer_thickness*1.5).into_iter())
        .collect();

}
pub fn gcode(layers:Vec<Vec<ToolPathLine>>)-> Result<(),io::Error>{
    let file = File::open("gcode.gcode")?;
    let mut buf_writer = BufWriter::new(file);

    let settings = Settings::default();

    writeheader(&mut buf_writer, &settings )?;

    for (i,layer) in layers.into_iter().enumerate() {
        if i == settings.layer_fan_start {
            writeln!(&mut buf_writer,"M106 ; Fan on")?;
        }
        write_layer(&mut buf_writer, layer )?;
    }

    Ok(())
}
pub struct LayerSettings{
    layer_number: usize,
    is_nonplanar: bool,
    retract_feedrate:f32,
    fan_start: bool,
    is_last_layer:bool,
}
fn write_layer<W:Write>(f:W,toolpath_lines:Vec<ToolPathLine>) -> Result<(),io::Error>{
    todo!()
}
// fn write_layer_py<W:Write>(f:W,s:LayerSettings,toolpath_lines:Vec<ToolPathLine>) -> Result<(),io::Error>{
//         // with open(self.output_path, 'a') as f:
//             writeln!(f,"\n;Start layer {}",s.layer_number)?;
//             writeln!(f,";     {} layer", if s.is_nonplanar {"Nonplanar"}else{"Planar"})?;
//             //writeln!(f,";     Nonplanar layer\n' if s.is_nonplanar else f';     Planar layer")?;
//             writeln!(f,"M117 Layer {}",s.layer_number)?;
//
//
//             // Set the extruder to 0
//             writeln!(f,"G92 E0.0 ; Reset extruder distance")?;
//             // f.write(f'G1 E-0.8 F{s.retract_feedrate}\n')
//
//             // Turn on fan 
//             if s.fan_start { writeln!(f,"M106 ; Fan on")?; }
//
//             for (i, line) in toolpath_lines.iter().enumerate(){
//                 let line = line.line;
//                 let line_type = line.line_type;
//                 let mut start = line[0];
//                 let mut end = line.last().unwrap();
//                 let translate_xy = Vector3::new(s.translate_xy[0],s.translate_xy[1],0.0);
//                 start += translate_xy;
//                 end += translate_xy;
//
//                 if i == 0{ // Move to the start of the first line
//                     writeln!(f,"f'G1 Z{s.safe_z:.3)} F{travel_feedrate}")?;
//                     writeln!(f,"G1 X{start[0]} Y{start[1]} F{travel_feedrate}")?;
//                     writeln!(f,"G1 Z{start[2]} F{travel_feedrate}")?;
//                     writeln!(f,"G1 E0.8 F{retract_feedrate}\n")?;  // De-retraction
//                     writeln!(f,"G92 E0.0")?;    // Reset extruder distance
//                 }
//
//                 let extrusion_length = np.round(s.extrusion_distances[i], 5);
//                 match line.line_type{
//                     ToolPathType::Travel{
//                         if round(abs(extrusion_length), 1) == 0.8 {
//                             writeln!(f,"f'G1 X{end[0]} Y{end[1]} Z{end[2]} E{extrusion_length} F{retract_feedrate} ; Retraction")?;
//                         }else{
//                             writeln!(f,"f'G1 X{end[0]} Y{end[1]} Z{end[2]} F{travel_feedrate} ; Travel")?;
//                          }
//                     },
//                     ToolPathType::Perimeter{
//                         if self.is_nonplanar{
//                             writeln!(f,"G1 X{end[0]} Y{end[1]} Z{end[2]} E{extrusion_length} F{extrusion_feedrate//2} ; Non-Planar Perimeter")?;
//                         }else{
//                             writeln!(f,"G1 X{end[0]} Y{end[1]} Z{end[2]} E{extrusion_length} F{extrusion_feedrate} ; Non-Planar Perimeter")?;
//                         }
//                     },
//                     ToolPathType::Infill{
//                         writeln!(f,"G1 X{end[0]} Y{end[1]} Z{end[2]} E{extrusion_length} F{extrusion_feedrate} ; {line_type.capitalize()}")?;
//                     },
//                 }
//             }
//
//             writeln!(f,"G1 E-0.8 F{}",s.retract_feedrate)?;  // Retraction
//             writeln!(f,"G1 Z{} F{travel_feedrate}",(np.around(self.safe_z, 3)))?;
//             writeln!(f,";End of layer {}",s.layer_number)?;
//
//             if s.is_last_layer {
//                 // Wipe (set relative mode, move to X2.0, Y2.0)
//                 writeln!('f,"G91 ; relative mode")?;
//                 writeln!(f,"G1 X2.0 Y2.0 E-0.4 F{} ; wipe and retract",s.travel_feedrate)?;
//                 writeln!(f,"G01 E-0.1 F{} ; retract some more",s.travel_feedrate)?;
//                 writeln!('f,"G90 ; absolute mode")?;
//
//                 // Turn off heaters and fan
//                 writeln!('f,"M104 S0 ; turn off extruder")?;
//                 writeln!('f,"M140 S0 ; turn off bed")?;
//                 writeln!('f,"M107 ; fan off")?;
//
//                 // Move up
//                 writeln!(f,"G1 Z{self.safe_z} F{} ; move up",s.travel_feedrate)?;
//
//                 // Present print
//                 writeln!(f,"G1 Y200 F{} ; present print",(s.travel_feedrate/2.0).floor())?;
//
//                 // Home x
//                 writeln!('f,"G28 X ; home x")?;
//
//                 // Turn off motors
//                 writeln!("M84 ; disable motors")?;
//             }
//
//         println!("Toolpath for layer {s.layer_number} appended to {self.output_path}");
//
//         if s.is_last_layer{ println!("Toolpath generation completed"); }
//
//         return Ok(())
// }
