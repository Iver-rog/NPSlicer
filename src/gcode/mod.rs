use nalgebra::{Matrix3, Point2, Point3, Vector2, Vector3};
use nalgebra_glm::{cross2d,cross};
use stl_io::{IndexedMesh, IndexedTriangle};

use std::io::{self,prelude,Write,BufWriter,BufReader};
use std::fs::File;

use crate::geo::{polygons_from_contours, ContorTrait, Contour, Contour3d, Enclosed, FromUnChecked, Polygon, Polygon3d};
use crate::stl_op;
use crate::skeleton::SkeletonBuilder;

mod projection;
use projection::edge_edge_intersection3d;



pub struct Settings{
    layer_thickness: f32,
    infill_percentage: usize,
    nozzle_diameter: f32,
    perimeter_line_width: f32,
    infill_line_width: f32,
    n_perimeters: usize,
    infill_overlap_percentage: usize,
    z_hop: f32,
       
    max_staydown_distance: f32,
    min_edge_length: f32,   // mm
    filament_diameter: f32, // mm
    layer_fan_start: usize,
    perimeter_start_xy: [isize;2],
    translate_xy: [usize;2],

    safe_z:f32,
}
impl Default for Settings {
    fn default() -> Self {
        let layer_thickness = 0.2;
        let nozzle_diameter = 0.6;
        let infill_percentage = 20;
        Self {
            layer_thickness,
            infill_percentage: 20,
            nozzle_diameter,
            perimeter_line_width: 0.45,
            infill_line_width: 0.6,
            n_perimeters: 2,
            infill_overlap_percentage: 0,
            z_hop: layer_thickness,
               
            max_staydown_distance: 1.5 * nozzle_diameter/((infill_percentage/100) as f32),
            min_edge_length: 0.5,       // mm
            filament_diameter: 1.75,    // mm
            layer_fan_start: 3,
            perimeter_start_xy: [-30, -15],
            translate_xy: [100, 100],

            safe_z: 0.0,
        }
    }
}

fn writeheader<W: Write>(f:&mut BufWriter<W>,settings:&Settings) -> Result<(),io::Error> {
    writeln!(f,"; Generated by layer-gen-rs")?;
    writeln!(f," Layer thickness: {}",settings.layer_thickness)?;
    writeln!(f," Nozzle diameter: {}",settings.nozzle_diameter)?;
    writeln!(f," Filament diameter: {}",settings.filament_diameter)?;
    writeln!(f,"; Perimeter line width: {}",settings.perimeter_line_width)?;
    writeln!(f,"; Infill line width: {}",settings.infill_line_width)?;
    // writeln!(f,"; Infill angle: {}",settings.infill_angle)?;
    // writeln!(f,"; Infill line spacing: {}",settings.infill_line_spacing)?;
    writeln!(f,"; Layer fan start: {}",settings.layer_fan_start)?;
    writeln!(f,"; Max staydown distance: {}",settings.max_staydown_distance)?;
    // writeln!(f,"; Seam position: {}",settings.seam_position)?;
    // writeln!(f,"; Translate XY: {translate_xy}")?;

    // Starting gcode from PrusaSlicer MK3 config
    writeln!(f,"M201 X1000 Y1000 Z200 E5000 ; sets maximum accelerations, mm/sec^2")?;
    writeln!(f,"M203 X200 Y200 Z12 E120 ; sets maximum feedrates, mm / sec")?;
    writeln!(f,"M204 S1250 T1250 ; sets acceleration (S) and retract acceleration (R), mm/sec^2")?;
    writeln!(f,"M205 X8.00 Y8.00 Z0.40 E4.50 ; sets the jerk limits, mm/sec")?;
    writeln!(f,"M205 S0 T0 ; sets the minimum extruding and travel feed rate, mm/sec")?;
    writeln!(f,"G90 ; use absolute coordinates")?;
    writeln!(f,"M83 ; extruder relative mode")?;
    writeln!(f,"M104 S180 ; set extruder preheat temp")?;
    writeln!(f,"M106 ; Fan on")?;
    writeln!(f,"M140 S60 ; set bed temp")?;
    writeln!(f,"M190 S60 ; wait for bed temp")?;
    writeln!(f,"M104 S215 ; set extruder temp")?;

    writeln!(f,"G28 W ; home all without mesh bed level")?;
    writeln!(f,"G80 ; mesh bed leveling")?;
    writeln!(f,"M104 S215 ; set extruder temp")?;
    writeln!(f,"M109 S215 ; wait for extruder temp")?;

    // Purge f,line
    writeln!(f,"G1 Z0.2 F720")?;
    writeln!(f,"G1 Y-3 F1000 ; go outside print area")?;
    writeln!(f,"G92 E0")?;
    writeln!(f,"M107 ; Fan off")?;
    writeln!(f,"G1 X60 E9 F1000 ; intro line")?;
    writeln!(f,"G1 X100 E12.5 F1000 ; intro line")?;
    writeln!(f,"G92 E0.0")?;

    writeln!(f,"M221 S100 ; M221 - Set extrude factor override percentage")?;
    writeln!(f,"G21 ; set units to millimeters")?;
    writeln!(f,"G90 ; use absolute coordinates")?;
    writeln!(f,"M83 ; use relative distances for extrusion")?;
    writeln!(f,"M900 K0.04 ; Filament gcode LA 1.5")?;
    writeln!(f,"M900 K18 ; Filament gcode LA 1.0")?;
    writeln!(f,"M107 ; Fan off")?;
    Ok(())
}
pub enum ToolPathType{
    Travel,
    Perimeter,
    Infill,
}
pub struct ToolPathLine{
    line:Vec<Point3<f32>>,
    line_type:ToolPathType,
}


pub fn main(blender:&mut crate::Blender) {
    // let args: Vec<String> = env::args().collect();
    // dbg!(&args);
    // let mut args = args.into_iter();
    // let path = args.next().expect("first arg should be the path");
    // let file = args.next().expect("missing argument: stl-layers directory");
    // println!("path:{path}");
    // println!("file:{file}");
    let settings = Settings::default();

    let file_path = "../mesh/bunny-overhang-regions.stl";

    let file = File::open(file_path).expect("Failed to open STL file");
    let mut reader = BufReader::new(file);
    let mesh = stl_io::read_stl(& mut reader).expect("Failed to parse STL file");
    blender.save_mesh(&mesh.faces,&mesh.vertices,String::from("as√∏ldkfj"));

    let (indexed_contours,indexed_edges) = stl_op::extract_perimeters_and_edges(&mesh.faces);

    for contour in &indexed_contours{
        blender.edge_loop(contour, &mesh);
    }
    let vertices = mesh.vertices.into_iter().map(|v|Point3::new( v[0],v[1],v[2]) ).collect();

    let mesh_collider = MeshCollider{
        faces:mesh.faces,
        edges:indexed_edges,
        vertices,
    };

    let contours:Vec<Contour> = indexed_contours.into_iter()
        .map(|indexed_contour|{
            Contour::from(
                indexed_contour.into_iter()
                    .map(|vertex_ndx|{
                        let v = mesh_collider.vertices[vertex_ndx];
                        Point2::new(v[0],v[1])
                    })
                    .collect::<Vec<Point2<f32>>>()
                )
        })
        .collect();

    let polygons = polygons_from_contours(contours);
    polygons.iter().for_each(|polygon|blender.polygon(polygon, 10.0));

    polygons.into_iter()
        .map(|polygon| SkeletonBuilder::from_polygon(polygon).unwrap())
        .flat_map(|skeleton| skeleton.offset_polygon(0.5).unwrap())
        // .map(|offset_polygon|offset_polygon.project_onto(&mesh_collider))
        // .for_each(|polygon3d| blender.polygon3d(&polygon3d) )
        .for_each(|polygon3d| blender.polygon(&polygon3d, 0.0) )

    // let offset_polygon = skeleton.offset_polygon(0.5).unwrap().into_iter().next().unwrap();
    // let offset_contour = offset_polygon.0[0].clone();
    // blender.contour(&offset_contour, 10.0);
    //
    // // blender.polygon(&offset_polygon,0.0);
    //
    //
    // let x = offset_contour.project_onto(&mesh_collider);
    // blender.contour3d(&x);

    // for ([start,end],normal) in x.0{
    //     let e:Point3<f32> = start + (0.5*(end - start)) ;
    //     // let e = Point3::new(10.,10.,10.);
    //     let n = e + normal;
    //     let points = vec![
    //         [e.x,e.y,e.z],
    //         [n.x,n.y,n.z]
    //     ];
    //     let edges = vec![[0,1]];
    //     blender.line_body3d(points, edges);
    // }

    // let perimeter1:Vec<Polygon> = polygons.clone().into_iter()
    //     .flat_map(|polygon:Polygon| polygon.offset(settings.layer_thickness*0.5).into_iter())
    //     .collect();
    // let perimeter2:Vec<Polygon> = polygons.into_iter()
    //     .flat_map(|polygon| polygon.offset(settings.layer_thickness*1.5).into_iter())
    //     .collect();
}
pub struct MeshCollider{
    pub faces:Vec<IndexedTriangle>,
    pub edges:Vec<stl_op::IndexedEdge>,
    pub vertices:Vec<Point3<f32>>,
}
impl Polygon{
    pub fn project_onto(&self,mesh:&MeshCollider) -> Polygon3d {
        let contours:Vec<Contour3d> = self.contours()
            .map(|contour| contour.project_onto(mesh))
            .collect();
        Polygon3d::from_unchecked(contours)
    }
}
impl Contour{
    pub fn project_onto(&self,mesh:&MeshCollider) -> Contour3d {
        project_contour_onto(self, mesh)
    }
}

pub fn project_point_onto(point:&Point2<f32>,mesh:&MeshCollider) -> Point3<f32> {
    mesh.faces.iter()
        .map(|face|(face.vertices,face.normal))
        .map(|(v,norm)|([mesh.vertices[v[0]],mesh.vertices[v[1]],mesh.vertices[v[2]]],norm))
        .filter(|(tri,norm)| tri.point_is_inside(&point))
        .filter_map(|(tri,norm)|{
            project_point_down(&point, &tri[0], norm)
        })
        .next()
        .unwrap()
}
pub fn project_contour_onto(contour:&Contour,mesh:&MeshCollider) -> Contour3d {

    Contour3d::from_unchecked( 
        contour.edges()
        .flat_map(|(e_start,e_end)|{
            let ed_vec = e_end-e_start;

            let mut intersections:Vec<(f32,f32)> = mesh.edges.iter()
                .filter_map(move |edge|{
                    let target_edge:[Point3<f32>;2] = [mesh.vertices[edge.0],mesh.vertices[edge.1]];

                    edge_edge_intersection3d([e_start,e_end],target_edge)
                })
                .collect();

            intersections.sort_unstable_by(|(t1,_),(t2,_)| t1.partial_cmp(t2).unwrap());

            let intersection_points:Vec<Point3<f32>> = intersections.into_iter()
                .map(move |(t,z)|{
                    let point2d = e_start + t*ed_vec;
                    Point3::new(point2d.x,point2d.y,z)
                }).collect();

            let first_point = project_point_onto(e_start, mesh);
            // intersection_points.into_iter()
            std::iter::once(first_point).chain(intersection_points.into_iter())
        })
    .collect()
    )
}
impl Enclosed for &[Point3<f32>;3]{
    fn area(&self) -> f32 {
        todo!()
    }
    fn point_is_inside(&self,point:&Point2<f32>) -> bool {
        let a = self[0].xy();
        let b = self[1].xy();
        let c = self[2].xy();

        let v0 = c - a;
        let v1 = b - a;
        let v2 = point - a;

        let dot00 = v0.dot(&v0);
        let dot01 = v0.dot(&v1);
        let dot02 = v0.dot(&v2);
        let dot11 = v1.dot(&v1);
        let dot12 = v1.dot(&v2);

        let denom = dot00 * dot11 - dot01 * dot01;
        if denom == 0.0 { return false } // Degenerate triangle

        let inv_denom = 1.0 / denom;
        let u = (dot11 * dot02 - dot01 * dot12) * inv_denom;
        let v = (dot00 * dot12 - dot01 * dot02) * inv_denom;

        return (u >= 0.0) && (v >= 0.0) && (u + v <= 1.0)
    }
}

fn project_point_down(point:&Point2<f32>, tri_pnt:&Point3<f32>, norm:stl_io::Vector<f32>) -> Option<Point3<f32>>{
    let normal = Vector3::new(norm[0],norm[1],norm[2]);
    if normal.z > 1e-5 {return None}
    // debug_assert!(normal.z > 1e-5); // <- face should not be parallell to the z-axis
    let a_point = Vector3::new(tri_pnt.x,tri_pnt.y,tri_pnt.z);

    // Solve for Z using plane equation:
    // normal ¬∑ (P - v0) = 0 ‚Üí normal_x * (x - x0) + normal_y * (y - y0) + normal_z * (z - z0) = 0
    let d = -normal.dot(&a_point);
    let z = -(normal[0] * point.x + normal[1] * point.y + d) / normal[2];
    Some(Point3::new(point.x, point.y, z))
}
fn vertical_ray_triangle_intersection(point:&Point2<f32>, [v0, v1, v2]:[Point3<f32>;3]) -> Option<Point3<f32>>{
    // Intersects a vertical ray pointing in the -Z direction with a triangle.
    //
    // Parameters:
    //     ray_origin (np.array): Starting point of the ray [x, y, z]
    //     v0, v1, v2 (np.array): Triangle vertices [x, y, z]
    //
    // Returns:
    //     hit (bool): True if the ray hits the triangle
    //     intersection (np.array): The intersection point [x, y, z] if hit, else None
    //     t (float): Distance along -Z from ray_origin to the triangle if hit, else None
    // Triangle edges and normal
    let edge1 = v1 - v0;
    let edge2 = v2 - v0;
    let normal:Vector3<f32> = edge1.cross(&edge2);

    debug_assert!(normal.z > 1e-5); // <- face should not be parallell to the z-axis

    // Solve for Z using plane equation:
    // normal ¬∑ (P - v0) = 0 ‚Üí normal_x * (x - x0) + normal_y * (y - y0) + normal_z * (z - z0) = 0
    // Solve for z:
    let v0v:Vector3<f32> = Vector3::new(v0.x,v0.y,v0.z);
    let d = -normal.dot(&v0v);
    let z = -(normal[0] * point.x + normal[1] * point.y + d) / normal[2];
    Some(Point3::new(point.x, point.y, z))
}

pub fn gcode(layers:Vec<Vec<ToolPathLine>>)-> Result<(),io::Error>{
    let file = File::open("gcode.gcode")?;
    let mut buf_writer = BufWriter::new(file);

    let settings = Settings::default();

    writeheader(&mut buf_writer, &settings )?;

    for (i,layer) in layers.into_iter().enumerate() {
        if i == settings.layer_fan_start {
            writeln!(&mut buf_writer,"M106 ; Fan on")?;
        }
        write_layer(&mut buf_writer, layer )?;
    }

    Ok(())
}
pub struct LayerSettings{
    layer_number: usize,
    is_nonplanar: bool,
    retract_feedrate:f32,
    fan_start: bool,
    is_last_layer:bool,
}
fn write_layer<W:Write>(f:W,toolpath_lines:Vec<ToolPathLine>) -> Result<(),io::Error>{
    todo!()
}
// fn write_layer_py<W:Write>(f:W,s:LayerSettings,toolpath_lines:Vec<ToolPathLine>) -> Result<(),io::Error>{
//         // with open(self.output_path, 'a') as f:
//             writeln!(f,"\n;Start layer {}",s.layer_number)?;
//             writeln!(f,";     {} layer", if s.is_nonplanar {"Nonplanar"}else{"Planar"})?;
//             //writeln!(f,";     Nonplanar layer\n' if s.is_nonplanar else f';     Planar layer")?;
//             writeln!(f,"M117 Layer {}",s.layer_number)?;
//
//
//             // Set the extruder to 0
//             writeln!(f,"G92 E0.0 ; Reset extruder distance")?;
//             // f.write(f'G1 E-0.8 F{s.retract_feedrate}\n')
//
//             // Turn on fan 
//             if s.fan_start { writeln!(f,"M106 ; Fan on")?; }
//
//             for (i, line) in toolpath_lines.iter().enumerate(){
//                 let line = line.line;
//                 let line_type = line.line_type;
//                 let mut start = line[0];
//                 let mut end = line.last().unwrap();
//                 let translate_xy = Vector3::new(s.translate_xy[0],s.translate_xy[1],0.0);
//                 start += translate_xy;
//                 end += translate_xy;
//
//                 if i == 0{ // Move to the start of the first line
//                     writeln!(f,"f'G1 Z{s.safe_z:.3)} F{travel_feedrate}")?;
//                     writeln!(f,"G1 X{start[0]} Y{start[1]} F{travel_feedrate}")?;
//                     writeln!(f,"G1 Z{start[2]} F{travel_feedrate}")?;
//                     writeln!(f,"G1 E0.8 F{retract_feedrate}\n")?;  // De-retraction
//                     writeln!(f,"G92 E0.0")?;    // Reset extruder distance
//                 }
//
//                 let extrusion_length = np.round(s.extrusion_distances[i], 5);
//                 match line.line_type{
//                     ToolPathType::Travel{
//                         if round(abs(extrusion_length), 1) == 0.8 {
//                             writeln!(f,"f'G1 X{end[0]} Y{end[1]} Z{end[2]} E{extrusion_length} F{retract_feedrate} ; Retraction")?;
//                         }else{
//                             writeln!(f,"f'G1 X{end[0]} Y{end[1]} Z{end[2]} F{travel_feedrate} ; Travel")?;
//                          }
//                     },
//                     ToolPathType::Perimeter{
//                         if self.is_nonplanar{
//                             writeln!(f,"G1 X{end[0]} Y{end[1]} Z{end[2]} E{extrusion_length} F{extrusion_feedrate//2} ; Non-Planar Perimeter")?;
//                         }else{
//                             writeln!(f,"G1 X{end[0]} Y{end[1]} Z{end[2]} E{extrusion_length} F{extrusion_feedrate} ; Non-Planar Perimeter")?;
//                         }
//                     },
//                     ToolPathType::Infill{
//                         writeln!(f,"G1 X{end[0]} Y{end[1]} Z{end[2]} E{extrusion_length} F{extrusion_feedrate} ; {line_type.capitalize()}")?;
//                     },
//                 }
//             }
//
//             writeln!(f,"G1 E-0.8 F{}",s.retract_feedrate)?;  // Retraction
//             writeln!(f,"G1 Z{} F{travel_feedrate}",(np.around(self.safe_z, 3)))?;
//             writeln!(f,";End of layer {}",s.layer_number)?;
//
//             if s.is_last_layer {
//                 // Wipe (set relative mode, move to X2.0, Y2.0)
//                 writeln!('f,"G91 ; relative mode")?;
//                 writeln!(f,"G1 X2.0 Y2.0 E-0.4 F{} ; wipe and retract",s.travel_feedrate)?;
//                 writeln!(f,"G01 E-0.1 F{} ; retract some more",s.travel_feedrate)?;
//                 writeln!('f,"G90 ; absolute mode")?;
//
//                 // Turn off heaters and fan
//                 writeln!('f,"M104 S0 ; turn off extruder")?;
//                 writeln!('f,"M140 S0 ; turn off bed")?;
//                 writeln!('f,"M107 ; fan off")?;
//
//                 // Move up
//                 writeln!(f,"G1 Z{self.safe_z} F{} ; move up",s.travel_feedrate)?;
//
//                 // Present print
//                 writeln!(f,"G1 Y200 F{} ; present print",(s.travel_feedrate/2.0).floor())?;
//
//                 // Home x
//                 writeln!('f,"G28 X ; home x")?;
//
//                 // Turn off motors
//                 writeln!("M84 ; disable motors")?;
//             }
//
//         println!("Toolpath for layer {s.layer_number} appended to {self.output_path}");
//
//         if s.is_last_layer{ println!("Toolpath generation completed"); }
//
//         return Ok(())
// }
