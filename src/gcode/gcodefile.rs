use std::io::{self,BufWriter,Write};
use std::fs::File;

use crate::geo::Contour3d;

pub struct Settings{
    layer_thickness: f32,
    infill_percentage: usize,
    nozzle_diameter: f32,
    perimeter_line_width: f32,
    infill_line_width: f32,
    n_perimeters: usize,
    infill_overlap_percentage: usize,
    z_hop: f32,
       
    max_staydown_distance: f32,
    min_edge_length: f32,   // mm
    filament_diameter: f32, // mm
    layer_fan_start: usize,
    perimeter_start_xy: [isize;2],
    translate_xy: [usize;2],

    // my own
    travel_feedrate:usize, // mm/s?
    retract_feedrate:usize,// mm/s?
    non_planar_travel_feedrate:usize,
    fan_start:usize, // at which layer the fan should turn on

    safe_z:f32,
}
impl Default for Settings {
    fn default() -> Self {
        let layer_thickness = 0.2;
        let nozzle_diameter = 0.6;
        let infill_percentage = 20;
        Self {
            layer_thickness,
            infill_percentage: 20,
            nozzle_diameter,
            perimeter_line_width: 0.45,
            infill_line_width: 0.6,
            n_perimeters: 2,
            infill_overlap_percentage: 0,
            z_hop: layer_thickness,
               
            max_staydown_distance: 1.5 * nozzle_diameter/((infill_percentage/100) as f32),
            min_edge_length: 0.5,       // mm
            filament_diameter: 1.75,    // mm
            layer_fan_start: 3,
            perimeter_start_xy: [-30, -15],
            translate_xy: [100, 100],

            travel_feedrate: 10800, // mm/s?
            retract_feedrate: 2500, // mm/s?
            non_planar_travel_feedrate: 5040, // mm/s?
            fan_start:3,

            safe_z: 0.0,
        }
    }
}

pub struct GcodeFile<'a>{
    file: BufWriter<File>,
    settings: &'a Settings,
    n_layer: usize,
}

impl GcodeFile<'_> {
    pub fn new<'a>(path:&'_ str, settings:&'a Settings) -> GcodeFile<'a> {
        let mut file = File::options()
            .read(true)
            .open(format!("{path}.gcode"))
            .unwrap();

        let mut buffer = BufWriter::new(file);
        writeheader(&mut buffer, settings);

        return GcodeFile { file:buffer, n_layer:0, settings }
    }

    pub fn layer(&mut self, contours: impl Iterator<Item = Contour3d>) -> Result<(),io::Error> {
        let f = &mut self.file;

        writeln!(f,"\n;Start layer {}",self.n_layer)?;
        writeln!(f,"M117 Layer {}",self.n_layer)?;
        self.n_layer += 1;

        // Set the extruder to 0
        writeln!(f,"G92 E0.0 ; Reset extruder distance")?;
        // f.write(f'G1 E-0.8 F{s.retract_feedrate}\n')

        if self.settings.fan_start == self.n_layer { writeln!(f,"M106 ; Fan on")?; }

        for contour in contours {
            let start = contour.0.first().unwrap();
            let end = contour.0.last().unwrap();
            writeln!(f,"G1 Z{:.3} F{:.3}",self.settings.safe_z,self.settings.travel_feedrate)?;
            writeln!(f,"G1 X{:.3} Y{:.3} F{:.3}",start.x,start.y,self.settings.travel_feedrate)?;
            writeln!(f,"G1 Z{:.3} F{:.3}",start.z,self.settings.travel_feedrate)?;
            writeln!(f,"G1 E0.8 F{:.3}",self.settings.retract_feedrate)?;  // De-retraction
            writeln!(f,"G92 E0.0")?;    // Reset extruder distance
        }



        todo!()

    }
}

fn writeheader<W: Write>(f:&mut BufWriter<W>,settings:&Settings) -> Result<(),io::Error> {
    writeln!(f,"; Generated by layer-gen-rs")?;
    writeln!(f," Layer thickness: {}",settings.layer_thickness)?;
    writeln!(f," Nozzle diameter: {}",settings.nozzle_diameter)?;
    writeln!(f," Filament diameter: {}",settings.filament_diameter)?;
    writeln!(f,"; Perimeter line width: {}",settings.perimeter_line_width)?;
    writeln!(f,"; Infill line width: {}",settings.infill_line_width)?;
    // writeln!(f,"; Infill angle: {}",settings.infill_angle)?;
    // writeln!(f,"; Infill line spacing: {}",settings.infill_line_spacing)?;
    writeln!(f,"; Layer fan start: {}",settings.layer_fan_start)?;
    writeln!(f,"; Max staydown distance: {}",settings.max_staydown_distance)?;
    // writeln!(f,"; Seam position: {}",settings.seam_position)?;
    // writeln!(f,"; Translate XY: {translate_xy}")?;

    // Starting gcode from PrusaSlicer MK3 config
    writeln!(f,"M201 X1000 Y1000 Z200 E5000 ; sets maximum accelerations, mm/sec^2")?;
    writeln!(f,"M203 X200 Y200 Z12 E120 ; sets maximum feedrates, mm / sec")?;
    writeln!(f,"M204 S1250 T1250 ; sets acceleration (S) and retract acceleration (R), mm/sec^2")?;
    writeln!(f,"M205 X8.00 Y8.00 Z0.40 E4.50 ; sets the jerk limits, mm/sec")?;
    writeln!(f,"M205 S0 T0 ; sets the minimum extruding and travel feed rate, mm/sec")?;
    writeln!(f,"G90 ; use absolute coordinates")?;
    writeln!(f,"M83 ; extruder relative mode")?;
    writeln!(f,"M104 S180 ; set extruder preheat temp")?;
    writeln!(f,"M106 ; Fan on")?;
    writeln!(f,"M140 S60 ; set bed temp")?;
    writeln!(f,"M190 S60 ; wait for bed temp")?;
    writeln!(f,"M104 S215 ; set extruder temp")?;

    writeln!(f,"G28 W ; home all without mesh bed level")?;
    writeln!(f,"G80 ; mesh bed leveling")?;
    writeln!(f,"M104 S215 ; set extruder temp")?;
    writeln!(f,"M109 S215 ; wait for extruder temp")?;

    // Purge f,line
    writeln!(f,"G1 Z0.2 F720")?;
    writeln!(f,"G1 Y-3 F1000 ; go outside print area")?;
    writeln!(f,"G92 E0")?;
    writeln!(f,"M107 ; Fan off")?;
    writeln!(f,"G1 X60 E9 F1000 ; intro line")?;
    writeln!(f,"G1 X100 E12.5 F1000 ; intro line")?;
    writeln!(f,"G92 E0.0")?;

    writeln!(f,"M221 S100 ; M221 - Set extrude factor override percentage")?;
    writeln!(f,"G21 ; set units to millimeters")?;
    writeln!(f,"G90 ; use absolute coordinates")?;
    writeln!(f,"M83 ; use relative distances for extrusion")?;
    writeln!(f,"M900 K0.04 ; Filament gcode LA 1.5")?;
    writeln!(f,"M900 K18 ; Filament gcode LA 1.0")?;
    writeln!(f,"M107 ; Fan off")?;
    Ok(())
}

// fn write_layer_py<W:Write>(f:W,s:LayerSettings,toolpath_lines:Vec<ToolPathLine>) -> Result<(),io::Error>{
//         // with open(self.output_path, 'a') as f:
//             writeln!(f,"\n;Start layer {}",s.layer_number)?;
//             writeln!(f,";     {} layer", if s.is_nonplanar {"Nonplanar"}else{"Planar"})?;
//             //writeln!(f,";     Nonplanar layer\n' if s.is_nonplanar else f';     Planar layer")?;
//             writeln!(f,"M117 Layer {}",s.layer_number)?;
//
//
//             // Set the extruder to 0
//             writeln!(f,"G92 E0.0 ; Reset extruder distance")?;
//             // f.write(f'G1 E-0.8 F{s.retract_feedrate}\n')
//
//             // Turn on fan 
//             if s.fan_start { writeln!(f,"M106 ; Fan on")?; }
//
//             for (i, line) in toolpath_lines.iter().enumerate(){
//                 let line = line.line;
//                 let line_type = line.line_type;
//                 let mut start = line[0];
//                 let mut end = line.last().unwrap();
//                 let translate_xy = Vector3::new(s.translate_xy[0],s.translate_xy[1],0.0);
//                 start += translate_xy;
//                 end += translate_xy;
//
//                 if i == 0{ // Move to the start of the first line
//                     writeln!(f,"f'G1 Z{s.safe_z:.3)} F{travel_feedrate}")?;
//                     writeln!(f,"G1 X{start[0]} Y{start[1]} F{travel_feedrate}")?;
//                     writeln!(f,"G1 Z{start[2]} F{travel_feedrate}")?;
//                     writeln!(f,"G1 E0.8 F{retract_feedrate}\n")?;  // De-retraction
//                     writeln!(f,"G92 E0.0")?;    // Reset extruder distance
//                 }
//
//                 let extrusion_length = np.round(s.extrusion_distances[i], 5);
//                 match line.line_type{
//                     ToolPathType::Travel{
//                         if round(abs(extrusion_length), 1) == 0.8 {
//                             writeln!(f,"f'G1 X{end[0]} Y{end[1]} Z{end[2]} E{extrusion_length} F{retract_feedrate} ; Retraction")?;
//                         }else{
//                             writeln!(f,"f'G1 X{end[0]} Y{end[1]} Z{end[2]} F{travel_feedrate} ; Travel")?;
//                          }
//                     },
//                     ToolPathType::Perimeter{
//                         if self.is_nonplanar{
//                             writeln!(f,"G1 X{end[0]} Y{end[1]} Z{end[2]} E{extrusion_length} F{extrusion_feedrate//2} ; Non-Planar Perimeter")?;
//                         }else{
//                             writeln!(f,"G1 X{end[0]} Y{end[1]} Z{end[2]} E{extrusion_length} F{extrusion_feedrate} ; Non-Planar Perimeter")?;
//                         }
//                     },
//                     ToolPathType::Infill{
//                         writeln!(f,"G1 X{end[0]} Y{end[1]} Z{end[2]} E{extrusion_length} F{extrusion_feedrate} ; {line_type.capitalize()}")?;
//                     },
//                 }
//             }
//
//             writeln!(f,"G1 E-0.8 F{}",s.retract_feedrate)?;  // Retraction
//             writeln!(f,"G1 Z{} F{travel_feedrate}",(np.around(self.safe_z, 3)))?;
//             writeln!(f,";End of layer {}",s.layer_number)?;
//
//             if s.is_last_layer {
//                 // Wipe (set relative mode, move to X2.0, Y2.0)
//                 writeln!('f,"G91 ; relative mode")?;
//                 writeln!(f,"G1 X2.0 Y2.0 E-0.4 F{} ; wipe and retract",s.travel_feedrate)?;
//                 writeln!(f,"G01 E-0.1 F{} ; retract some more",s.travel_feedrate)?;
//                 writeln!('f,"G90 ; absolute mode")?;
//
//                 // Turn off heaters and fan
//                 writeln!('f,"M104 S0 ; turn off extruder")?;
//                 writeln!('f,"M140 S0 ; turn off bed")?;
//                 writeln!('f,"M107 ; fan off")?;
//
//                 // Move up
//                 writeln!(f,"G1 Z{self.safe_z} F{} ; move up",s.travel_feedrate)?;
//
//                 // Present print
//                 writeln!(f,"G1 Y200 F{} ; present print",(s.travel_feedrate/2.0).floor())?;
//
//                 // Home x
//                 writeln!('f,"G28 X ; home x")?;
//
//                 // Turn off motors
//                 writeln!("M84 ; disable motors")?;
//             }
//
//         println!("Toolpath for layer {s.layer_number} appended to {self.output_path}");
//
//         if s.is_last_layer{ println!("Toolpath generation completed"); }
//
//         return Ok(())
// }



// NOTE: Might not be a good idea to do it this way
impl Drop for GcodeFile<'_> {
    fn drop(&mut self){
        let f = &mut self.file;
        // Wipe (set relative mode, move to X2.0, Y2.0)
        writeln!(f,"G91 ; relative mode");
        writeln!(f,"G1 X2.0 Y2.0 E-0.4 F{} ; wipe and retract",self.settings.travel_feedrate);
        writeln!(f,"G01 E-0.1 F{} ; retract some more",self.settings.travel_feedrate);
        writeln!(f,"G90 ; absolute mode");

        // Turn off heaters and fan
        writeln!(f,"M104 S0 ; turn off extruder");
        writeln!(f,"M140 S0 ; turn off bed");
        writeln!(f,"M107 ; fan off");

        // Move up
        writeln!(f,"G1 Z{} F{} ; move up",self.settings.safe_z,self.settings.travel_feedrate);

        // Present print
        writeln!(f,"G1 Y200 F{} ; present print",(self.settings.travel_feedrate/2));

        // Home x
        writeln!(f,"G28 X ; home x");

        // Turn off motors
        writeln!(f,"M84 ; disable motors");
    }
}
